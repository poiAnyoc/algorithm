# 算法project

## Cognitive time complexity  认识时间复杂度
```
    对数理解
        log2^n = log2^9 * log9^n
    log2^n、log9^n  称为logn
    
    
    1、复杂度
        a、时间复杂度  估算程序指令的执行次数 （执行时间）
        b、空间复杂度  估算所需占用的存储空间
        c、大O表示法  （big o）  估算
            1）o是描述复杂度，表示的是数据规模n对应的复杂度
            2）当o大到一定长度时，忽略常数、系数、低阶
                a）9  >> O(1)
                b）2n + 3  >> O(n)
                c）n^2 + 2n + 3  >> O(n^2)
                d）4n^3 +  3n^2 + 22n + 1000  >> O(n^3)
                d）4n^3 +  3n^2 + 22n + 1000  >> O(n^3)
            3）O(1)为常数  渐进复杂度     
        d、平均复杂度
        e、均摊复杂度
        f、复杂度震荡
    2、线性表
        a、数组
            1）动态数组
            2）自己实现arrayList与jdk比较
            3）arrayList优化
        b、链表
            1）单向链表
            2）双向链表
            3）单向循环链表
            4）双向循环列表
            5）静态链表
            6）LinkedList实现与jdk比较
        c、栈、stack自实现以及分析
        d、队列
            1）循环队列
            2）双端队列
            3）循环双端队列
            4）Queue自己实现与jdk比较
            5）Deque自己实现与jdk比较
    3、树
        a、满二叉树
        b、完全二叉树
        c、二叉搜索树
        d、平衡二叉搜索树
            1）AVL树
            2）红黑树
        e、B树 2-3-4树   n阶B树
        f、堆
            1）大顶堆
            2）小顶堆
            3）优先队列
            4）PriorityQueue自己实现与jdk中分析
        g、Trie
        h、哈夫曼树
    4、映射 TreeMap自己实现与jdk源代码分析                                    
    5、集合 TreeSet自己实现与jdk源代码分析                                    
    6、哈希表
        a、哈希函数
        b、哈希冲突
        c、动态扩容
        d、HashSet自己实现与jdk源代码分析
        e、HashMap自己实现与jdk源代码分析
        f、LinkedHashSet自己实现与jdk源代码分析
        g、LinkedHashMap自己实现与jdk源代码分析

```

| 执行次数 | 复杂度 | 非正式 /
|---|---|---|
| 12 | O(1) | 常数阶 |
| 2n +3 | O(n) | 线性阶 |
| 4n^2 + 2n + 6 | O(n^2) | 平方阶 |
| 4log2^n + 25 | O(logn) | 对数阶 |
| 3n + 2nlog3^n + 15 | O(nlogn) | nlogn阶 |
| 4n^3 + 3n^2 + 22n + 100 + 15 | O(n^3) | 立方阶 |
| 2^n | O(2^n) | 指数阶 |


## sort 排序

```
    常见排序：冒泡、选择、插入、归并、快速、希尔、堆属于比较排序()
    
    1、冒泡排序（BubbleSort）
        又叫做起泡排序
        逐一比较，每次比较前一个值与后一个值、若大于则swap交换往后移动、 冒泡就是一点点的浮出水面
        (1)从头开始比较每一对相邻的元素，如果第1个比第2个大，就交换他们的位置
        (2)第一次比较，最后一个数就是最大的数
        (3)冒泡的优化，
            a、提前给出的数组就是排完序的（序列已经是有序、可以提前终止冒泡排序  optimizeSort1） 
               相当于在循环第一轮或者勋魂第n轮得知 已经是拍好序的
            b、发现数组的尾部已经存在局部有序，就可以记录最后一次交换的位置，减少比较的次数
            
    2、选择排序（SelectionSort）
        (1) 从数组中找出最大的元素，将这个最大的元素与数组的最后一个元素交换位置
        (2) 排除这个最大的元素 也就是排除数组的最后一个元素，继续扫描循环这个数组 找出最大的元素，继续交换位置
        (3) 依次类推
        (4) 选择排序的交换凑数 要远远少于冒泡排序，平均性能优先于冒泡排序
        (5) 最好、最坏、平均的时间复杂度：O(n^2) 空间复杂度：O(1)， 不稳定排序
        (6)选择的优化：
            a、将第二层for循环挑出最大值，这个循环 改成堆，使用堆来选出最值
            
    3、插入排序（InsertionSort）
    4、堆排序（HeapSort）
        (1) 堆排序可以认为是对选择排序的一种优化
        (2)执行流程：
            a、对数组进行原地建堆 (heapify)
            b、重复执行以下操作，知道堆的元素为1
                — 交换堆顶元素与末尾元素
                — 堆的元素数量减1
                — 对0的位置进行1次 siftDown操作
                
    5、快速排序（QuickSort）
    6、希尔排序（ShellSort）
    7、归并排序（MergeSort）
    8、基数排序（RadixSort）
    9、计数排序（CountSort）
    10、桶排序（BucketSort）

```


## 算法2

```
    1、排序
        a、冒泡排序
        b、选择排序
        c、插入排序
        d、希尔排序
        e、归并排序
        f、快速排序
        g、堆排序
        h、计数排序
        i、桶排序
        j、基数排序
    2、图
        a、基础
            1）有向图、入度、出度
            2）无向图、混合图
            3）简单图、多重图
            4）完全图、稀疏图、稠密图
            5）连通图、联通分量
        b、应用
            1）邻接矩阵
            2）邻接表
            3）深度优先搜索
            4）广度优先搜索
            5）AOV网、拓扑排序、Kahn算法
        c、最小生成树
            1）Prim算法
            2）Kruskal算法
        d、最短路径
            1）Dijkstra算法
            2）Bellman-Ford算法
            2）Floyd算法
    3、串
        a、KMP算法
        b、Boyer-Moore算法
        c、Karp-Rabin算法
        d、Sunday算法
    4、算法策略
        a、递归
        b、回溯
        c、贪心
        d、分治
            1）大整数乘法
            2）最大序列和
        e、动态规划
            1）斐波那契数
            2）幂运算
            3）最长公共子序列
            4）最长递增子序列
            5）0-1背包问题
    5、数据结构
        a、跳表
        b、布隆过滤器
        c、B+树、B*树
        d、并查集
            1）Quick Find
            2）Quick Union
            3）Path Compression
            4）Path Halving
            5）Path Splitting
    6、应用
        a、leetcode
        b、面试题

```


## leetcode 力扣算法练习