# 算法project

## Cognitive time complexity  认识时间复杂度
```
    对数理解
        log2^n = log2^9 * log9^n
    log2^n、log9^n  称为logn
    
    
    1、复杂度
        a、时间复杂度  估算程序指令的执行次数 （执行时间）
        b、空间复杂度  估算所需占用的存储空间
        c、大O表示法  （big o）  估算
            1）o是描述复杂度，表示的是数据规模n对应的复杂度
            2）当o大到一定长度时，忽略常数、系数、低阶
                a）9  >> O(1)
                b）2n + 3  >> O(n)
                c）n^2 + 2n + 3  >> O(n^2)
                d）4n^3 +  3n^2 + 22n + 1000  >> O(n^3)
                d）4n^3 +  3n^2 + 22n + 1000  >> O(n^3)
            3）O(1)为常数  渐进复杂度     
        d、平均复杂度
        e、均摊复杂度
        f、复杂度震荡
    2、线性表
        a、数组
            1）动态数组
            2）自己实现arrayList与jdk比较
            3）arrayList优化
        b、链表
            1）单向链表
            2）双向链表
            3）单向循环链表
            4）双向循环列表
            5）静态链表
            6）LinkedList实现与jdk比较
        c、栈、stack自实现以及分析
            (1) 栈是一种特殊的线性表，只能在一端操作
                往栈中添加元素的操作叫push，入栈
                往栈中移除元素的操作叫pop，出栈（只能移除栈顶 元素，也叫作：弹出栈顶元素）
                先进后出原则
            (2) Stack使用继承  但是不推荐 继承下来会暴露太多问题，Stack2中聚合了一个List<E> 方便扩展    
                
        d、队列
            队列时一种特殊的线性表，只能在头尾两端进行操作
            底层也可以使用动态数组来实现，哥哥接口优化到O（1） 也叫作：循环队列
            队尾(rear)：只能从队尾添加元素，一般叫做enQueue，入队
            队头(front)：只能从对头移除元素，一般叫做deQueue，出队
            先进先出的原则
            1）循环队列 底层用数组来实现
            2）双端队列（Deque） double ended queue
                双端队列能够在头尾两端添加、删除的队列
            3）循环双端队列（Circle Queue）
                可以进行两端的添加、删除操作的循环队列
                
            4）Queue自己实现与jdk比较
            5）Deque自己实现与jdk比较
    3、树
        a、满二叉树
        b、完全二叉树
        c、二叉搜索树
        d、平衡二叉搜索树
            1）AVL树
            2）红黑树
        e、B树 2-3-4树   n阶B树
        f、堆
            1）大顶堆
            2）小顶堆
            3）优先队列
            4）PriorityQueue自己实现与jdk中分析
        g、Trie
        h、哈夫曼树
    4、映射 TreeMap自己实现与jdk源代码分析                                    
    5、集合 TreeSet自己实现与jdk源代码分析                                    
    6、哈希表
        a、哈希函数
        b、哈希冲突
        c、动态扩容
        d、HashSet自己实现与jdk源代码分析
        e、HashMap自己实现与jdk源代码分析
        f、LinkedHashSet自己实现与jdk源代码分析
        g、LinkedHashMap自己实现与jdk源代码分析

```

| 执行次数 | 复杂度 | 非正式 /
|---|---|---|
| 12 | O(1) | 常数阶 |
| 2n +3 | O(n) | 线性阶 |
| 4n^2 + 2n + 6 | O(n^2) | 平方阶 |
| 4log2^n + 25 | O(logn) | 对数阶 |
| 3n + 2nlog3^n + 15 | O(nlogn) | nlogn阶 |
| 4n^3 + 3n^2 + 22n + 100 + 15 | O(n^3) | 立方阶 |
| 2^n | O(2^n) | 指数阶 |


## 树

```
                    1
        2      3      4      5      6    
   21   22   31            51  52   61
      221 222  223
   
   * 树的概念
   1、节点、根节点、父节点、子节点、兄弟节点
        1）节点：每个元素都称为节点
        2）根节点：1棵树最多只有一个根节点， 1              
        3）父节点：1称作为2 3 4 5 6     2称作为是21 22的父节点       
        4）子节点：2 3 4 5 6称作为是1的子节点  21 22称作为2的子节点      
        5）兄弟节点：同一个父节点下的兄弟节点  2 3 4 5 6称作为是兄弟节点     
   2、一棵树可以没有任何节点，称为空树
   3、一棵树可以只有1个节点，也就是根节点
   4、子树、左子树、右子树
        1）子树：（2  21 22  221  222  223）（3  31）（4）（5  51  52）（6  61）称作为1的子树
        2）左子树：5  51  52，51称为是5的左子树
        3）右子树：5  51  52，52称为是5的右子树
   5、节点的度（degree）：子树的个数 譬如：1有5个子树代表度是5
   6、树的度：所有节点度中的最大值  譬如：1
   7、叶子节点（leaf）：度为0的节点  譬如：221 222 223 51  52  61  4都称为是叶子节点 
   8、非叶子节点：度不为0的节点
   9、层数（level）：根节点在第一层，根节点的子节点是在第2层，以此类推（有些也从第0层开始计算）  譬如：4层
   10、节点的深度（depth）：从根节点到当前节点的唯一路径上的节点总数  譬如：2 他经历了1和2两个节点，所以他的深度是2
   11、节点的高度（height）：从当前节点到最远叶子结点的路径上的节点总数  譬如：2下面最远的经历了2 22 221，所以他的高度是3
   12、树的深度：所有节点的深度中最大值  4 
   13、树的高度：所有节点的高度中最大值  4
   14、树的深度等于树的高度
   15、有序树、无序树、森林
   16、
   17、
   18、
   19、
   20、
   21、
   22、
   23、




```


## sort 排序

```
    常见排序：冒泡、选择、插入、归并、快速、希尔、堆属于比较排序()
    
    1、冒泡排序（BubbleSort）
        又叫做起泡排序
        逐一比较，每次比较前一个值与后一个值、若大于则swap交换往后移动、 冒泡就是一点点的浮出水面
        (1)从头开始比较每一对相邻的元素，如果第1个比第2个大，就交换他们的位置
        (2)第一次比较，最后一个数就是最大的数
        (3)冒泡的优化，
            a、提前给出的数组就是排完序的（序列已经是有序、可以提前终止冒泡排序  optimizeSort1） 
               相当于在循环第一轮或者循环第n轮得知 已经是排好序的
            b、发现数组的尾部已经存在局部有序，就可以记录最后一次交换的位置，减少比较的次数
            
    2、选择排序（SelectionSort）
        (1) 从数组中找出最大的元素，将这个最大的元素与数组的最后一个元素交换位置
        (2) 排除这个最大的元素 也就是排除数组的最后一个元素，继续扫描循环这个数组 找出最大的元素，继续交换位置
        (3) 依次类推
        (4) 选择排序的交换次数 要远远少于冒泡排序，平均性能优先于冒泡排序
        (5) 最好、最坏、平均的时间复杂度：O(n^2) 空间复杂度：O(1)， 不稳定排序
        (6)选择的优化：
            a、将第二层for循环挑出最大值，这个循环 改成堆，使用堆来选出最值
            
    3、堆排序（HeapSort）
        (1) 堆排序可以认为是对选择排序的一种优化  不稳定排序
        (2)执行流程：
            a、对数组进行原地建堆 (heapify)
            b、重复执行以下操作，知道堆的元素为1
                — 交换堆顶元素与末尾元素
                — 堆的元素数量减1
                — 对0的位置进行1次 siftDown操作
                
    4、插入排序（InsertionSort）
        (1) 插入排序类似于扑克牌排序
        (2) 第一个元素排序无意义 直接从第二个元素开始，从头开始扫描 将他插入到合适的头部位置  并保持头部数据依然是有序
        (3) 逆序对(Inversion)
            a、数组[2, 3, 8, 6, 1]   所以为：[2,1] [3,1] [8,1] [8,6] [6,1] 共五个逆序对
        (4) 逆序对数量越多，插入排序的时间就越多    当逆序对数量越少的时候，效率特别高，比O(nlogn)级别快速排序还要快
            数组量不是特别大的时候也特别快
        (5) 复杂度： 最好、最坏复杂度：O(n^2)  最好时间复杂度： O(n)
        (6) 插入优化：
            a、参考对应的optimizeSort1
                交换次数太多 记录将要插入的元素，将有序数据中比待插入元素大的时候，都向尾部方向挪动1个位置  最后将记录的元素插入合适的位置
            b、参考对应的optimizeSort2
                二分搜索优化  平均的时间复杂度仍然是O(n^2)
                要求必须查找返回插入的位置：第一个出现大雨value的元素位置
          
    5、归并排序（MergeSort）
        (1) 不断的将当前数组序列分割都2个子序列，一直到不能再分割为止（相当于只剩下一个元素的时候）
            再不断的将2个子序列合并成一个有序序列，一直到只剩下一个有序序列
        (2) 复杂度：O(nlogn)    
            归并排序总是平均的分割子序列，所以最好、最坏的平均时间复杂度都是O(nlogn) 属于稳定排序
            空间复杂度：O(n / 2 + logn) = o(n)
        
    6、快速排序（QuickSort）
        (1) 从数组中选择一个轴点元素 p   每次选择的p为第0号位置来当做轴点元素
            利用p 将序列分割成2个子数组，将小于p的元素放在p的左侧，将大于p的元素放在p的右侧，等于p的元素放在哪边都乐意
            对子数组继续循环操作，一直到不能分割为止  （只剩下1个元素）
        (2) 本质上就是 每次分割都将第一个元素作为p的元素
        (3) 复杂度： 最好、平均时间复杂度：O(nlogn)  最坏时间复杂度：O(n^2)
            递归调用 空间复杂度为：O(logn)  不稳定排序
        
    7、希尔排序（ShellSort）
    8、基数排序（RadixSort）
    9、计数排序（CountSort）
    10、桶排序（BucketSort）

```


## 算法2

```
    1、排序
        a、冒泡排序
        b、选择排序
        c、插入排序
        d、希尔排序
        e、归并排序
        f、快速排序
        g、堆排序
        h、计数排序
        i、桶排序
        j、基数排序
    2、图
        a、基础
            1）有向图、入度、出度
            2）无向图、混合图
            3）简单图、多重图
            4）完全图、稀疏图、稠密图
            5）连通图、联通分量
        b、应用
            1）邻接矩阵
            2）邻接表
            3）深度优先搜索
            4）广度优先搜索
            5）AOV网、拓扑排序、Kahn算法
        c、最小生成树
            1）Prim算法
            2）Kruskal算法
        d、最短路径
            1）Dijkstra算法
            2）Bellman-Ford算法
            2）Floyd算法
    3、串
        a、KMP算法
        b、Boyer-Moore算法
        c、Karp-Rabin算法
        d、Sunday算法
    4、算法策略
        a、递归
        b、回溯
        c、贪心
        d、分治
            1）大整数乘法
            2）最大序列和
        e、动态规划
            1）斐波那契数
            2）幂运算
            3）最长公共子序列
            4）最长递增子序列
            5）0-1背包问题
    5、数据结构
        a、跳表
        b、布隆过滤器
        c、B+树、B*树
        d、并查集
            1）Quick Find
            2）Quick Union
            3）Path Compression
            4）Path Halving
            5）Path Splitting
    6、应用
        a、leetcode
        b、面试题

```


## leetcode 力扣算法练习